--==============================
-- SERVICES
--==============================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")

--==============================
-- PLAYER / CAMERA
--==============================
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

--==============================
-- BIẾN TRẠNG THÁI & LƯU TRẠNG THÁI CŨ
--==============================
local s
local basePart
local activeDamage = false

local camShake
local camShakeRunning = false
local cc
local damageLoopRunning = true

-- store tables (lưu trạng thái ban đầu để revert)
local storedParticles = {}       -- array of { obj = ParticleEmitter, prevEnabled = bool, prevColor = ColorSequence or nil }
local storedFaceEmitters = {}    -- subset (same structure as above)
local storedPointLights = {}     -- array of { obj = PointLight, prevEnabled = bool, prevRange = number }

--==============================
-- HÀM LẤY ROOM
--==============================
local function GetRoom()
	return workspace.CurrentRooms:FindFirstChild(
		ReplicatedStorage.GameData.LatestRoom.Value
	)
end

--==============================
-- LOAD ENTITY MODEL
--==============================
s = game:GetObjects("rbxassetid://111891528214795")[1]
s.Parent = workspace

basePart = s:FindFirstChildWhichIsA("BasePart", true)
if not basePart then
	warn("Không tìm thấy BasePart trong entity")
	return
end

basePart.Anchored = true
s.PrimaryPart = basePart

-- Spawn vị trí
local room = GetRoom()
if room and room:FindFirstChild("RoomEntrance") then
	basePart.CFrame = room.RoomEntrance.CFrame * CFrame.new(0, 0, -15)
end

--==============================
-- ÂM THANH (giữ nguyên nếu có)
--==============================
if basePart:FindFirstChild("Playsound") then
	pcall(function()
		basePart.Playsound.Volume = 2
		basePart.Playsound:Play()
	end)
end

--==============================
-- TẮT TOÀN BỘ HIỆU ỨNG BAN ĐẦU (và LƯU TRẠNG THÁI)
--==============================
-- Dùng map 'seen' để tránh thêm trùng emitters nhiều lần
local seenEmitters = {}

-- Thu mọi ParticleEmitter trong basePart (ưu tiên basePart descendants)
for _, obj in ipairs(basePart:GetDescendants()) do
	if obj:IsA("ParticleEmitter") and not seenEmitters[obj] then
		seenEmitters[obj] = true
		local entry = {
			obj = obj,
			prevEnabled = obj.Enabled,
			prevColor = obj.Color
		}
		table.insert(storedParticles, entry)

		-- Nếu tên là 'face' (so sánh không phân biệt hoa thường) thì set color đen và lưu vào subset
		if string.lower(obj.Name) == "face" then
			table.insert(storedFaceEmitters, entry)
			pcall(function() obj.Color = ColorSequence.new(Color3.fromRGB(0,0,0)) end)
		end

		-- Tắt emitter ngay
		pcall(function() obj.Enabled = false end)
	end
end

-- Thu thêm ParticleEmitter nằm ngoài basePart nhưng trong model (tránh trùng bằng seenEmitters)
for _, obj in ipairs(s:GetDescendants()) do
	if obj:IsA("ParticleEmitter") and not seenEmitters[obj] then
		seenEmitters[obj] = true
		local entry = {
			obj = obj,
			prevEnabled = obj.Enabled,
			prevColor = obj.Color
		}
		table.insert(storedParticles, entry)

		if string.lower(obj.Name) == "Face" then
			table.insert(storedFaceEmitters, entry)
			pcall(function() obj.Color = ColorSequence.new(Color3.fromRGB(0,0,0)) end)
		end

		pcall(function() obj.Enabled = true end)
	end
end

-- Lưu và tắt PointLights (trong basePart)
for _, obj in ipairs(basePart:GetDescendants()) do
	if obj:IsA("PointLight") then
		local entry = { obj = obj, prevEnabled = obj.Enabled, prevRange = obj.Range }
		table.insert(storedPointLights, entry)
		pcall(function() obj.Enabled = false end)
	end
end

--==============================
-- COLOR CORRECTION (tạo nếu chưa có)
--==============================
cc = Lighting:FindFirstChild("ColorCorrection")
if not cc then
	cc = Instance.new("ColorCorrectionEffect")
	cc.Name = "ColorCorrection"
	cc.Parent = Lighting
end

--==============================
-- SAU 5 GIÂY: PHỤC HỒI/TWEEN & BẬT HIỆU ỨNG
--==============================
task.delay(5, function()
	if not s or not s.Parent then return end

	-- Bật lại particle emitters: theo yêu cầu trước đây bạn muốn bật tất cả đã tắt -> mình bật tất cả
	for _, entry in ipairs(storedParticles) do
		if entry.obj and entry.obj.Parent then
			pcall(function() entry.obj.Enabled = true end)
		end
	end

	-- Tween Face emitters: từ màu đen (hiện tại) -> đỏ trong 3s
	for _, entry in ipairs(storedFaceEmitters) do
		local emitter = entry.obj
		if emitter and emitter.Parent then
			-- đảm bảo bật emitter
			pcall(function() emitter.Enabled = true end)

			-- smooth color change vì TweenService không ổn định với ColorSequence
			local duration = 3
			local steps = 30
			for i = 1, steps do
				if not (emitter and emitter.Parent) then break end
				local t = i / steps
				local r = math.floor(0 + (255 - 0) * t)
				local color = Color3.fromRGB(math.clamp(r,0,255), 0, 0)
				pcall(function() emitter.Color = ColorSequence.new(color) end)
				task.wait(duration / steps)
			end
			pcall(function() emitter.Color = ColorSequence.new(Color3.fromRGB(255,0,0)) end)
		end
	end

	-- Tween PointLights: bật và tween Range -> 30 trong 3s
	for _, entry in ipairs(storedPointLights) do
		local pl = entry.obj
		if pl and pl.Parent then
			pcall(function() pl.Enabled = true end)
			pcall(function()
				local tw = TweenService:Create(pl, TweenInfo.new(3, Enum.EasingStyle.Linear), {Range = 30})
				tw:Play()
			end)
		end
	end

	-- Tween Lighting sang đỏ (TintColor)
	pcall(function()
		local tw = TweenService:Create(cc, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TintColor = Color3.fromRGB(255,0,0)})
		tw:Play()
	end)

	-- Camera Shake (bắt đầu)
	local success, CameraShaker = pcall(function() return require(ReplicatedStorage:WaitForChild("CameraShaker")) end)
	if success and CameraShaker then
		camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
			-- bảo vệ camera nil
			if workspace.CurrentCamera then
				workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame * shakeCf
			end
		end)
		pcall(function() camShake:Start() end)
		pcall(function() camShake:ShakeOnce(30, 3, 0.1, 6, 2, 0.5) end)
		camShakeRunning = true
	end

	-- Bật flag gây dame (kể từ đây radius kiểm tra sẽ tác dụng)
	activeDamage = true
end)

--==============================
-- DAMAGE LOOP (500 STUDS)
--==============================
task.spawn(function()
	while damageLoopRunning do
		task.wait(1)

		if not activeDamage then continue end
		if not s or not s.Parent then break end

		local char = player.Character
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		local hrp = char and char:FindFirstChild("HumanoidRootPart")

		if hum and hrp and basePart then
			if (hrp.Position - basePart.Position).Magnitude <= 500 then
				hum.Health = math.max(0, hum.Health - 1.5)
				pcall(function()
					ReplicatedStorage.GameStats["Player_"..player.Name].Total.DeathCause.Value = "sussasion"
				end)
			end
		end
	end
end)

--==============================
-- CLEANUP KHI SANG ROOM MỚI (revert state)
--==============================
workspace.CurrentRooms.ChildAdded:Connect(function()
	-- stop damage loop & flag
	damageLoopRunning = false
	activeDamage = false

	-- stop camera shake
	if camShakeRunning and camShake then
		pcall(function() if type(camShake.Stop) == "function" then camShake:Stop() end end)
		camShakeRunning = false
		camShake = nil
	end

	-- revert ColorCorrection (nếu cần set về trắng trung tính)
	if cc then
		pcall(function()
			cc.TintColor = Color3.fromRGB(255,255,255)
			cc.Contrast = 0
			cc.Saturation = 0
		end)
	end

	-- revert particle emitters -> restore prevEnabled and prevColor
	for _, entry in ipairs(storedParticles) do
		local obj = entry.obj
		if obj and obj.Parent then
			pcall(function()
				obj.Enabled = entry.prevEnabled
				if entry.prevColor then
					obj.Color = entry.prevColor
				end
			end)
		end
	end

	-- revert pointlights
	for _, entry in ipairs(storedPointLights) do
		local obj = entry.obj
		if obj and obj.Parent then
			pcall(function()
				obj.Enabled = entry.prevEnabled
				obj.Range = entry.prevRange
			end)
		end
	end

	-- finally destroy model
	if s and s.Parent then
		pcall(function() s:Destroy() end)
	end

	-- clear tables
	storedParticles = {}
	storedFaceEmitters = {}
	storedPointLights = {}
end)
